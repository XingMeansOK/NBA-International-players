{"dependencies":[{"name":"./lib/three.js","loc":{"line":1,"column":21}},{"name":"./constant.js","loc":{"line":2,"column":25}},{"name":"./layercontainer.js","loc":{"line":3,"column":30}},{"name":"./autocamera.js","loc":{"line":4,"column":26}},{"name":"./layers/pillarlayer.js","loc":{"line":213,"column":29}}],"generated":{"js":"var THREE = require( './lib/three.js' );\r\nvar constants = require( './constant.js' );\r\nvar LayerContainer = require( './layercontainer.js' );\r\nvar AutoCamera = require( './autocamera.js' );\r\n// var PillarLayer = require( './layers/pillarlayer.js' );\r\n\r\n/*\r\n  MapboxWrapper:  mapboxgl.Map的包装类\r\n  封装了使用threejs对mapboxgl.Map的操作\r\n  @param map MapboxGL的Map对象\r\n\r\n        ******实际上，所有的可视化绘制和mapboxgl的绘图上下文没有任何关系，因为根本就不在一个canvas里。\r\n        两个canvas相当于两个图层，我们绘制的三维要素在上层的canvas里，地图在下层的canvas里，然后两者叠加在一起\r\n        看了一下uber的deckgl，也是用了两个canvas，地图一个，三维要素一个\r\n        而echarts-gl甚至用了三个canvas\r\n*/\r\nfunction MapboxWrapper( map ) {\r\n\r\n  // 保存当前对象包装的Map实例的引用\r\n  this.map = map;\r\n\r\n  /********初始化自定义三维要素的绘图环境********/\r\n\r\n  // 创建渲染器，开启透明绘制和抗锯齿。\r\n  var renderer = this.renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );\r\n  // 设置画布尺寸\r\n  // Map对象的transform属性中保存了大量与地图相关的信息，还有很多和Webgl相关的信息\r\n  renderer.setSize( map.transform.width, map.transform.height ); // width和height记录了canvas的像素值\r\n  // 当map大小改变的时候，renderer的canvas也跟着改变\r\n  map.on( 'resize', function() {\r\n    renderer.setSize( map.transform.width, map.transform.height );\r\n  } )\r\n  // 开启阴影贴图\r\n  renderer.shadowMap.enabled = true;\r\n\r\n  /*********将渲染器的canvas节点添加到Map的父节点下********/\r\n\r\n  map._container.appendChild( renderer.domElement );\r\n  // 修改样式使其覆盖在Map的canvas上\r\n  renderer.domElement.style[ 'position' ] = 'relative';\r\n  // 鼠标事件在传播（捕获、冒泡）过程中将无视renderer的canvas。\r\n  // 如果想让这个canvas的子节点响应鼠标事件，单独设置子节点的pointer-events属性就可以了\r\n  renderer.domElement.style[ 'pointer-events' ] = 'none';\r\n  renderer.domElement.style[ 'z-index' ] = '999';\r\n\r\n  /*****创建场景*****/\r\n\r\n  this.scene = new THREE.Scene();\r\n  // 自动同步map的平移、缩放变换（model矩阵）\r\n  this.layerContainer = new LayerContainer( map ); // scene下的顶层根节点，所有绘制的three object3d都包含在其中\r\n  this.scene.add( this.layerContainer );\r\n\r\n  /********创建一个和mapboxgl的摄像机完全同步的摄像机*********/\r\n\r\n  // 自动同步vp矩阵（视图矩阵和投影矩阵）\r\n  this.camera = new AutoCamera( map );\r\n\r\n  /********渲染场景*********/\r\n\r\n  this.animate();\r\n\r\n}\r\n\r\nObject.assign( MapboxWrapper.prototype, {\r\n\r\n  /*\r\n    逐帧渲染\r\n  */\r\n  animate: function () {\r\n\r\n    // 传入requestAnimationFrame内的函数的调用者是window，所以要确保这个函数在他的作用域链中能找到当前mapboxWrapper对象的引用\r\n    var scope = this;\r\n    requestAnimationFrame( function() { scope.animate() } );\r\n\r\n    this.render();\r\n\r\n  },\r\n\r\n  /*\r\n    渲染函数\r\n  */\r\n  render: function() {\r\n\r\n    // 函数私有的变量\r\n\r\n    var lastFrame, currentFrame; // 渲染上一帧的时间，渲染当前帧的时间（用于计算两帧间的时间差）\r\n\r\n    return function() {\r\n        this.renderer.render( this.scene, this.camera );\r\n    }\r\n\r\n  }(),\r\n\r\n  /*\r\n    在指定位置添加three要素\r\n    @param obj:Mesh\r\n    @param lnglat: Array 经纬度\r\n    @param options: Object\r\n  */\r\n  addAtCoordinate: function(obj, lnglat, options) {\r\n       var geoGroup = new THREE.Group();\r\n       geoGroup.userData.isGeoGroup = true;\r\n       geoGroup.add(obj);\r\n       this.layerContainer.add(geoGroup);\r\n       this.moveToCoordinate(obj, lnglat, options);\r\n\r\n       // Bestow this mesh with animation superpowers and keeps track of its movements in the global animation queue\r\n       //this.animationManager.enroll(obj);\r\n\r\n       return obj;\r\n   },\r\n   moveToCoordinate: function(obj, lnglat, options) {\r\n       /** Place the given object on the map, centered around the provided longitude and latitude\r\n           The object's internal coordinates are assumed to be in meter-offset format, meaning\r\n           1 unit represents 1 meter distance away from the provided coordinate.\r\n       */\r\n\r\n       if (options === undefined) options = {};\r\n       if(options.preScale === undefined) options.preScale = 1.0;\r\n       if(options.scaleToLatitude === undefined || obj.userData.scaleToLatitude) options.scaleToLatitude = true;\r\n\r\n       obj.userData.scaleToLatitude = options.scaleToLatitude;\r\n\r\n       if (typeof options.preScale === 'number') options.preScale = new THREE.Vector3(options.preScale, options.preScale, options.preScale);\r\n       else if(options.preScale.constructor === Array && options.preScale.length === 3) options.preScale = new THREE.Vector3(options.preScale[0], options.preScale[1], options.preScale[2]);\r\n       else if(options.preScale.constructor !== THREE.Vector3) {\r\n           console.warn(\"Invalid preScale value: number, Array with length 3, or THREE.Vector3 expected. Defaulting to [1,1,1]\");\r\n           options.preScale = new THREE.Vector3(1,1,1);\r\n       }\r\n\r\n       var scale = options.preScale;\r\n\r\n       // Figure out if this object is a geoGroup and should be positioned and scaled directly, or if its parent\r\n       var geoGroup;\r\n       if (obj.userData.isGeoGroup) geoGroup = obj;\r\n       else if (obj.parent && obj.parent.userData.isGeoGroup) geoGroup = obj.parent;\r\n       else return console.error(\"Cannot set geographic coordinates of object that does not have an associated GeoGroup. Object must be added to scene with 'addAtCoordinate()'.\")\r\n\r\n       if(options.scaleToLatitude) {\r\n           // Scale the model so that its units are interpreted as meters at the given latitude\r\n           var pixelsPerMeter = this.projectedUnitsPerMeter(lnglat[1]);\r\n           scale.multiplyScalar(pixelsPerMeter);\r\n       }\r\n\r\n       geoGroup.scale.copy(scale);\r\n\r\n       geoGroup.position.copy(this.projectToWorld(lnglat));\r\n       obj.coordinates = lnglat;\r\n\r\n       return obj;\r\n   },\r\n\r\n   projectedUnitsPerMeter: function(latitude) {\r\n       return Math.abs( 512 * ( 1 / Math.cos( latitude * Math.PI / 180 ) ) / 40075000 );\r\n       // 40075000是地球周长（单位米）\r\n   },\r\n\r\n   projectToWorld: function (coords){\r\n       // Spherical mercator forward projection, re-scaling to WORLD_SIZE\r\n       /*\r\n       将经纬度转成webgl坐标，正好对应mapbox geo/transform的lngX、latY两个方法\r\n\r\n            * latitude to absolute x coord\r\n            * @returns {number} pixel coordinate\r\n\r\n            lngX(lng: number) {\r\n               return (180 + lng) * this.worldSize / 360;\r\n            }\r\n\r\n           * latitude to absolute y coord\r\n           * @returns {number} pixel coordinate\r\n\r\n            latY(lat: number) {\r\n                const y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));\r\n                return (180 - y) * this.worldSize / 360;\r\n            }\r\n       */\r\n       var projected = [\r\n           -constants.MERCATOR_A * coords[0] * constants.DEG2RAD * constants.PROJECTION_WORLD_SIZE,\r\n           -constants.MERCATOR_A * Math.log(Math.tan((Math.PI*0.25) + (0.5 * coords[1] * constants.DEG2RAD))) * constants.PROJECTION_WORLD_SIZE\r\n       ];\r\n\r\n       var pixelsPerMeter = this.projectedUnitsPerMeter(coords[1]);\r\n\r\n       //z dimension\r\n       var height = coords[2] || 0;\r\n       projected.push( height * pixelsPerMeter );\r\n\r\n       var result = new THREE.Vector3(projected[0], projected[1], projected[2]);\r\n\r\n       return result;\r\n   },\r\n\r\n   /*\r\n      添加柱状图层\r\n      @param options:Object\r\n   */\r\n   addPillarLayer: function( options ) {\r\n\r\n     this.layerContainer.add( new PillarLayer( options ) );\r\n\r\n   },\r\n\r\n   /*\r\n      添加柱状图层\r\n      @param options:Object\r\n   */\r\n   addLayer: function( options ) {\r\n\r\n     // \r\n     var subclasses = {\r\n\r\n      'pillarlayer': require('./layers/pillarlayer.js'),\r\n\r\n     };\r\n\r\n     this.layerContainer.add( new subclasses[ options.type ]( options ) )\r\n\r\n   }\r\n\r\n\r\n} )\r\n\r\n\r\nmodule.exports = MapboxWrapper;\r\n"},"hash":"e7b4ebaf6bad4c611749bf8784f20e9d"}