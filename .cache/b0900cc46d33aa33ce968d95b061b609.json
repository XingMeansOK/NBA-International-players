{"dependencies":[{"name":"./lib/three.js","loc":{"line":1,"column":21}}],"generated":{"js":"var THREE = require( './lib/three.js' );\r\n\r\n/*\r\n  MapboxWrapper:  mapboxgl.Map的包装类\r\n  封装了使用threejs对mapboxgl.Map的操作\r\n  @param map MapboxGL的Map对象\r\n\r\n        ******实际上，所有的可视化绘制和mapboxgl的绘图上下文没有任何关系，因为根本就不在一个canvas里。\r\n        两个canvas相当于两个图层，我们绘制的三维要素在上层的canvas里，地图在下层的canvas里，然后两者叠加在一起\r\n        看了一下uber的deckgl，也是用了两个canvas，地图一个，三维要素一个\r\n        而echarts-gl甚至用了三个canvas\r\n*/\r\nfunction MapboxWrapper( map ) {\r\n\r\n  // 保存当前对象包装的Map实例的引用\r\n  this.map = map;\r\n\r\n\r\n  /********初始化自定义三维要素的绘图环境********/\r\n\r\n  // 创建渲染器，开启透明绘制和抗锯齿。\r\n  var renderer = this.renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );\r\n  // 设置画布尺寸\r\n  // Map对象的transform属性中保存了大量与地图相关的信息，还有很多和Webgl相关的信息\r\n  renderer.setSize( map.transform.width, map.transform.height );\r\n  // 当map大小改变的时候，renderer的canvas也跟着改变\r\n  map.on( 'resize', function() {\r\n    renderer.setSize( map.transform.width, map.transform.height );\r\n  } )\r\n  // 开启阴影贴图\r\n  renderer.shadowMap.enabled = true;\r\n\r\n  /*********将渲染器的canvas节点添加到Map的父节点下********/\r\n\r\n  map._container.appendChild( renderer.domElement );\r\n  // 修改样式使其覆盖在Map的canvas上\r\n  renderer.domElement.style[ 'position' ] = 'relative';\r\n  // 鼠标事件在传播（捕获、冒泡）过程中将无视renderer的canvas。\r\n  // 如果想让这个canvas的子节点响应鼠标事件，单独设置子节点的pointer-events属性就可以了\r\n  renderer.domElement.style[ 'pointer-events' ] = 'none';\r\n  renderer.domElement.style[ 'z-index' ] = '999';\r\n\r\n  /********创建一个和mapboxgl的摄像机完全同步的摄像机*********/\r\n\r\n  this.camera = new THREE.PerspectiveCamera( 90, map.transform.width / map.transform.height, 0.1, 10000 ); // 摄像机的初始化参数无所谓\r\n  this.synchronizeCameras(); // 同步three.js摄像机和mapboxgl摄像机，这个函数调用之后两个摄像机将一直保持同步\r\n\r\n  /*****创建场景*****/\r\n\r\n  this.scene = new THREE.Scene();\r\n\r\n  /********渲染场景*********/\r\n\r\n  this.animate();\r\n\r\n}\r\n\r\nObject.assign( MapboxWrapper.prototype, {\r\n\r\n  /*\r\n    同步three.js摄像机和mapboxgl摄像机，并保持同步\r\n  */\r\n  synchronizeCameras: function() {\r\n\r\n    var map = this.map;\r\n    var camera = this.camera;\r\n\r\n    // 确保three摄像机和mapboxgl.map都绑定了\r\n    if( !map || !camera ) return;\r\n    // 同步摄像机的函数，先同步一次\r\n    ( function _synchronizeCameras() {\r\n\r\n    }() )\r\n\r\n    // 地图从一个视图到另一个视图的转换过程中重复触发\r\n    map.on( 'move', function() { _synchronizeCameras(); } );\r\n  },\r\n\r\n  /*\r\n    逐帧渲染\r\n  */\r\n  animate: function () {\r\n\r\n    // 传入requestAnimationFrame内的函数的调用者是window，所以要确保这个函数在他的作用域链中能找到当前mapboxWrapper对象的引用\r\n    var scope = this;\r\n    requestAnimationFrame( function() { scope.animate() } );\r\n\r\n    this.render();\r\n\r\n  },\r\n\r\n  /*\r\n    渲染函数\r\n  */\r\n  render: function() {\r\n\r\n    // 函数私有的变量\r\n\r\n    var lastFrame, currentFrame; // 渲染上一帧的时间，渲染当前帧的时间（用于计算两帧间的时间差）\r\n\r\n    return function() {\r\n        this.renderer.render( this.scene, this.camera );\r\n    }\r\n\r\n  }(),\r\n\r\n\r\n\r\n} )\r\n\r\nmodule.exports = MapboxWrapper;\r\n"},"hash":"81f33ea5f1a1093d93ea4ba227945be4"}