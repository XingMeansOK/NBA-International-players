{"dependencies":[{"name":"./lib/three.js","loc":{"line":1,"column":21}}],"generated":{"js":"var THREE = require( './lib/three.js' );\r\n\r\nvar WORLD_SIZE = 512;\r\nvar MERCATOR_A = 6378137.0;\r\n\r\nvar ThreeboxConstants = {\r\n    WORLD_SIZE: WORLD_SIZE,\r\n    PROJECTION_WORLD_SIZE: WORLD_SIZE / (MERCATOR_A * Math.PI) / 2,\r\n    MERCATOR_A: MERCATOR_A, // 900913 projection property 地球半径\r\n    DEG2RAD: Math.PI / 180,\r\n    RAD2DEG: 180 / Math.PI,\r\n    EARTH_CIRCUMFERENCE: 40075000, // In meters\r\n}\r\n\r\n/*\r\n  MapboxWrapper:  mapboxgl.Map的包装类\r\n  封装了使用threejs对mapboxgl.Map的操作\r\n  @param map MapboxGL的Map对象\r\n\r\n        ******实际上，所有的可视化绘制和mapboxgl的绘图上下文没有任何关系，因为根本就不在一个canvas里。\r\n        两个canvas相当于两个图层，我们绘制的三维要素在上层的canvas里，地图在下层的canvas里，然后两者叠加在一起\r\n        看了一下uber的deckgl，也是用了两个canvas，地图一个，三维要素一个\r\n        而echarts-gl甚至用了三个canvas\r\n*/\r\nfunction MapboxWrapper( map ) {\r\n\r\n  // 保存当前对象包装的Map实例的引用\r\n  this.map = map;\r\n\r\n\r\n  /********初始化自定义三维要素的绘图环境********/\r\n\r\n  // 创建渲染器，开启透明绘制和抗锯齿。\r\n  var renderer = this.renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );\r\n  // 设置画布尺寸\r\n  // Map对象的transform属性中保存了大量与地图相关的信息，还有很多和Webgl相关的信息\r\n  renderer.setSize( map.transform.width, map.transform.height ); // width和height记录了canvas的像素值\r\n  // 当map大小改变的时候，renderer的canvas也跟着改变\r\n  map.on( 'resize', function() {\r\n    renderer.setSize( map.transform.width, map.transform.height );\r\n  } )\r\n  // 开启阴影贴图\r\n  renderer.shadowMap.enabled = true;\r\n\r\n  /*********将渲染器的canvas节点添加到Map的父节点下********/\r\n\r\n  map._container.appendChild( renderer.domElement );\r\n  // 修改样式使其覆盖在Map的canvas上\r\n  renderer.domElement.style[ 'position' ] = 'relative';\r\n  // 鼠标事件在传播（捕获、冒泡）过程中将无视renderer的canvas。\r\n  // 如果想让这个canvas的子节点响应鼠标事件，单独设置子节点的pointer-events属性就可以了\r\n  renderer.domElement.style[ 'pointer-events' ] = 'none';\r\n  renderer.domElement.style[ 'z-index' ] = '999';\r\n\r\n  /*****创建场景*****/\r\n\r\n  this.scene = new THREE.Scene();\r\n  this.world = new THREE.Group(); // 所有three绘制的根节点，同时也方便进行坐标变换\r\n  this.scene.add( this.world );\r\n\r\n  /********创建一个和mapboxgl的摄像机完全同步的摄像机*********/\r\n\r\n  this.camera = new THREE.PerspectiveCamera( 90, map.transform.width / map.transform.height, 0.1, 10000 ); // 摄像机的初始化参数无所谓\r\n  this.synchronizeCameras(); // 同步three.js摄像机和mapboxgl摄像机，这个函数调用之后两个摄像机将一直保持同步\r\n  // this.cameraSynchronizer = new CameraSync(this.map, this.camera, this.world);\r\n  /********渲染场景*********/\r\n\r\n  this.animate();\r\n\r\n}\r\n\r\nObject.assign( MapboxWrapper.prototype, {\r\n\r\n  /*\r\n    同步three.js摄像机和mapboxgl摄像机，并保持同步\r\n  */\r\n  synchronizeCameras: function() {\r\n\r\n    var map = this.map;\r\n    var camera = this.camera;\r\n    var world = this.world;\r\n    var FOV = 0.6435011087932844; // 摄像机fovy，是个固定值\r\n    var HALFFOV = FOV / 2; // 摄像机fovy的一半\r\n    var TILESIZE = 512; // 对应mapbox的transform.tileSize; 瓦片的尺寸\r\n\r\n    // 确保three摄像机和mapboxgl.map都绑定了\r\n    if( !map || !camera ) return;\r\n\r\n    // 设置为true时，每一帧都会重新计算matrix矩阵，并重新计算matrixWorld，这里要手动控制姿态，所以设置为false。\r\n    camera.matrixAutoUpdate = false;\r\n    // ??????????\r\n    world.position.x = world.position.y = ThreeboxConstants.WORLD_SIZE / 2;\r\n    world.matrixAutoUpdate = false;\r\n\r\n     // 计算投影矩阵的函数 参数就是视锥上下截面夹角，宽高比，近截面，远截面\r\n     // 返回一个THREE.Matrix4对象\r\n    function _calcPerspectiveMatrix( fovy, aspect, near, far ) {\r\n      var out = new THREE.Matrix4();\r\n      var f = 1.0 / Math.tan( fovy / 2 ),\r\n      nf = 1 / ( near - far );\r\n      out.elements[0] = f / aspect;\r\n      out.elements[1] = 0;\r\n      out.elements[2] = 0;\r\n      out.elements[3] = 0;\r\n      out.elements[4] = 0;\r\n      out.elements[5] = f;\r\n      out.elements[6] = 0;\r\n      out.elements[7] = 0;\r\n      out.elements[8] = 0;\r\n      out.elements[9] = 0;\r\n      out.elements[10] = ( far + near ) * nf;\r\n      out.elements[11] = -1;\r\n      out.elements[12] = 0;\r\n      out.elements[13] = 0;\r\n      out.elements[14] = ( 2 * far * near ) * nf;\r\n      out.elements[15] = 0;\r\n      return out;\r\n    }\r\n\r\n    // 同步摄像机的函数，\r\n    function _synchronizeCameras() {\r\n\r\n      // mapboxgl的map有一个transform属性，是一个Transform类型的对象实例，其源码位于mapbox-gl-js/src/geo/transform.js\r\n      // transform记录了摄像机的姿态，每次改变姿态都会调用transform._calcMatrices()方法\r\n      // 来重新计算摄像机的矩阵\r\n\r\n      // mapboxgl的摄像机运动规律：\r\n      /*\r\n        前提：map的canvas大小不变。\r\n        视锥：视锥只有在摄像机与地图平面的倾角（map.transform.pitch）改变时，改变远截面的位置。其余都不变\r\n        摄像机位置：摄像机相对世界坐标原点的距离始终不变，改变视线方向是使摄像机，绕x轴或z轴旋转（想象下手柄摇杆，手动挡那种）\r\n        平移：移动的是地图，但是仅限于xy平面内。改变地图的全局变换矩阵\r\n        缩放：改变的是地图，因为摄像机的距离和fov都没变。缩放的过程中还有地图的分级问题，我觉得是没用移动摄像机或者地图平面的原因\r\n      */\r\n\r\n      // 因为是同步mapboxgl的摄像机参数，所以就是重构transform._calcMatrices()方法\r\n\r\n      /*****计算视锥******/\r\n\r\n      // 摄像机到世界坐标原点的距离\r\n      var cameraToCenterDistance = 0.5 / Math.tan( FOV / 2 ) * map.transform.height; // height是mapboxgl canvas的高度（pixel）\r\n\r\n      /*\r\n        只要窗口尺寸不变，canvas大小就不变，map.transform.height就不变\r\n        至于为什么一个像素单位等于webgl世界坐标系中一个单位长度，_calcMatrices中有这样一句注释：\r\n        1 Z unit is equivalent to 1 horizontal px at the center of the map\r\n        (the distance between[width/2, height/2] and [width/2 + 1, height/2])\r\n\r\n        1米单位长度与像素的换算关系为\r\n        1米 = 屏幕分辨率的高/裁剪面的高 = h / (2*tan(HALFFOV)*z) = 1的话，所以z = h/(2*tan(HALFFOV))\r\n        这样就保证了一个单位长度转换成了一个像素\r\n      */\r\n\r\n\r\n      var groundAngle = Math.PI / 2 + map.transform._pitch; // pitch只能绕x轴正方向旋转（右手定则），最大60度\r\n      // 视锥上截面与xoy平面交线的中点到世界坐标原点的距离\r\n      var topHalfSurfaceDistance = Math.sin( HALFFOV ) * cameraToCenterDistance / Math.sin( Math.PI - groundAngle - HALFFOV );\r\n      // Calculate z distance of the farthest fragment that should be rendered.\r\n      var furthestDistance = Math.cos( Math.PI / 2 - map.transform._pitch ) * topHalfSurfaceDistance + cameraToCenterDistance;\r\n      // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\r\n      var farZ = furthestDistance * 1.01; // 视锥远截面位置get\r\n\r\n      // 计算投影矩阵\r\n      camera.projectionMatrix = _calcPerspectiveMatrix( FOV, map.transform.width / map.transform.height, 1, farZ );\r\n\r\n      /*****计算摄像机的姿态*****/\r\n\r\n      // 参照threebox的代码，将投影矩阵和坐标变换分开\r\n      var cameraWorldMatrix = new THREE.Matrix4();\r\n      var cameraTranslateZ = new THREE.Matrix4().makeTranslation( 0, 0, cameraToCenterDistance );\r\n      var cameraRotateX = new THREE.Matrix4().makeRotationX( map.transform._pitch );\r\n      var cameraRotateZ = new THREE.Matrix4().makeRotationZ( map.transform.angle );\r\n\r\n      // Unlike the Mapbox GL JS camera, separate camera translation and rotation out into its world matrix\r\n      // If this is applied directly to the projection matrix, it will work OK but break raycasting\r\n      cameraWorldMatrix\r\n          .premultiply( cameraTranslateZ )\r\n          .premultiply( cameraRotateX )\r\n          .premultiply( cameraRotateZ )\r\n\r\n      camera.matrixWorld.copy(cameraWorldMatrix); // 平移和缩放都不会改变这个矩阵，只有旋转会\r\n\r\n      /*****计算three绘制的要素的变换矩阵，使其与地图的平移和缩放同步*****/\r\n\r\n      // transform.scale = Math.pow(2, zoom)，2的zoom次幂。zoom是地图的缩放级别，0-22，可以是小数\r\n      var zoomPow = map.transform.scale;\r\n      var scale = new THREE.Matrix4();\r\n      var translateCenter = new THREE.Matrix4();\r\n      var translateMap = new THREE.Matrix4();\r\n      var rotateMap = new THREE.Matrix4();\r\n\r\n      scale.makeScale( zoomPow, zoomPow , zoomPow );\r\n      translateCenter.makeTranslation( TILESIZE / 2, -TILESIZE / 2, 0 );\r\n      translateMap.makeTranslation( -map.transform.x, map.transform.y, 0 );\r\n      rotateMap.makeRotationZ( Math.PI );\r\n      world.matrix = new THREE.Matrix4();\r\n      world.matrix\r\n          .premultiply( rotateMap )\r\n          .premultiply( translateCenter )\r\n          .premultiply( scale )\r\n          .premultiply( translateMap )\r\n\r\n          // world.matrixWorldNeedsUpdate = true;\r\n\r\n\r\n\r\n\r\n    };\r\n\r\n    // 地图从一个视图到另一个视图的转换过程中重复触发\r\n    map.on( 'move', function() { _synchronizeCameras(); } );\r\n    // 先同步一次\r\n    _synchronizeCameras();\r\n  },\r\n\r\n  /*\r\n    逐帧渲染\r\n  */\r\n  animate: function () {\r\n\r\n    // 传入requestAnimationFrame内的函数的调用者是window，所以要确保这个函数在他的作用域链中能找到当前mapboxWrapper对象的引用\r\n    var scope = this;\r\n    requestAnimationFrame( function() { scope.animate() } );\r\n\r\n    this.render();\r\n\r\n  },\r\n\r\n  /*\r\n    渲染函数\r\n  */\r\n  render: function() {\r\n\r\n    // 函数私有的变量\r\n\r\n    var lastFrame, currentFrame; // 渲染上一帧的时间，渲染当前帧的时间（用于计算两帧间的时间差）\r\n\r\n    return function() {\r\n        this.renderer.render( this.scene, this.camera );\r\n    }\r\n\r\n  }(),\r\n\r\n  addAtCoordinate: function(obj, lnglat, options) {\r\n       var geoGroup = new THREE.Group();\r\n       geoGroup.userData.isGeoGroup = true;\r\n       geoGroup.add(obj);\r\n       // this._flipMaterialSides(obj);\r\n       this.world.add(geoGroup);\r\n       this.moveToCoordinate(obj, lnglat, options);\r\n\r\n       // Bestow this mesh with animation superpowers and keeps track of its movements in the global animation queue\r\n       //this.animationManager.enroll(obj);\r\n\r\n       return obj;\r\n   },\r\n   moveToCoordinate: function(obj, lnglat, options) {\r\n       /** Place the given object on the map, centered around the provided longitude and latitude\r\n           The object's internal coordinates are assumed to be in meter-offset format, meaning\r\n           1 unit represents 1 meter distance away from the provided coordinate.\r\n       */\r\n\r\n       if (options === undefined) options = {};\r\n       if(options.preScale === undefined) options.preScale = 1.0;\r\n       if(options.scaleToLatitude === undefined || obj.userData.scaleToLatitude) options.scaleToLatitude = true;\r\n\r\n       obj.userData.scaleToLatitude = options.scaleToLatitude;\r\n\r\n       if (typeof options.preScale === 'number') options.preScale = new THREE.Vector3(options.preScale, options.preScale, options.preScale);\r\n       else if(options.preScale.constructor === Array && options.preScale.length === 3) options.preScale = new THREE.Vector3(options.preScale[0], options.preScale[1], options.preScale[2]);\r\n       else if(options.preScale.constructor !== THREE.Vector3) {\r\n           console.warn(\"Invalid preScale value: number, Array with length 3, or THREE.Vector3 expected. Defaulting to [1,1,1]\");\r\n           options.preScale = new THREE.Vector3(1,1,1);\r\n       }\r\n\r\n       var scale = options.preScale;\r\n\r\n       // Figure out if this object is a geoGroup and should be positioned and scaled directly, or if its parent\r\n       var geoGroup;\r\n       if (obj.userData.isGeoGroup) geoGroup = obj;\r\n       else if (obj.parent && obj.parent.userData.isGeoGroup) geoGroup = obj.parent;\r\n       else return console.error(\"Cannot set geographic coordinates of object that does not have an associated GeoGroup. Object must be added to scene with 'addAtCoordinate()'.\")\r\n\r\n       if(options.scaleToLatitude) {\r\n           // Scale the model so that its units are interpreted as meters at the given latitude\r\n           var pixelsPerMeter = this.projectedUnitsPerMeter(lnglat[1]);\r\n           scale.multiplyScalar(pixelsPerMeter);\r\n       }\r\n\r\n       geoGroup.scale.copy(scale);\r\n\r\n       geoGroup.position.copy(this.projectToWorld(lnglat));\r\n       obj.coordinates = lnglat;\r\n\r\n       return obj;\r\n   },\r\n\r\n   projectedUnitsPerMeter: function(latitude) {\r\n       return Math.abs( 512 * ( 1 / Math.cos( latitude * Math.PI / 180 ) ) / 40075000 );\r\n       // 40075000是地球周长（单位米）\r\n   },\r\n\r\n   projectToWorld: function (coords){\r\n       // Spherical mercator forward projection, re-scaling to WORLD_SIZE\r\n       /*\r\n       将经纬度转成webgl坐标，正好对应mapbox geo/transform的lngX、latY两个方法\r\n\r\n            * latitude to absolute x coord\r\n            * @returns {number} pixel coordinate\r\n\r\n            lngX(lng: number) {\r\n               return (180 + lng) * this.worldSize / 360;\r\n            }\r\n\r\n           * latitude to absolute y coord\r\n           * @returns {number} pixel coordinate\r\n\r\n            latY(lat: number) {\r\n                const y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));\r\n                return (180 - y) * this.worldSize / 360;\r\n            }\r\n       */\r\n       var projected = [\r\n           -ThreeboxConstants.MERCATOR_A * coords[0] * ThreeboxConstants.DEG2RAD * ThreeboxConstants.PROJECTION_WORLD_SIZE,\r\n           -ThreeboxConstants.MERCATOR_A * Math.log(Math.tan((Math.PI*0.25) + (0.5 * coords[1] * ThreeboxConstants.DEG2RAD))) * ThreeboxConstants.PROJECTION_WORLD_SIZE\r\n       ];\r\n\r\n       var pixelsPerMeter = this.projectedUnitsPerMeter(coords[1]);\r\n\r\n       //z dimension\r\n       var height = coords[2] || 0;\r\n       projected.push( height * pixelsPerMeter );\r\n\r\n       var result = new THREE.Vector3(projected[0], projected[1], projected[2]);\r\n\r\n       return result;\r\n   },\r\n\r\n\r\n} )\r\n\r\n\r\nmodule.exports = MapboxWrapper;\r\n"},"hash":"c0255c52c21c3c6b553d93ec27d77108"}