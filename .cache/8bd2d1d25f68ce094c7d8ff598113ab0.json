{"dependencies":[{"name":"./lib/three.js","loc":{"line":1,"column":21}},{"name":"./constant.js","loc":{"line":2,"column":25}}],"generated":{"js":"var THREE = require( './lib/three.js' );\r\nvar constants = require( './constant.js' );\r\n\r\n/*\r\n   Scene\r\n    \\\r\n    LayerContainer --light\r\n     |      \\\r\n    Layer  Layer\r\n\r\n    LayerContainer是所有图层的根节点，为了配合mapbox，LayerContainer还包含了坐标变换\r\n    LayerContainer继承自Three的Group类\r\n    @param map：Mapboxgl Map对象\r\n*/\r\nfunction LayerContainer( map ) {\r\n\r\n  if( !map ) return;\r\n\r\n  THREE.Group.call( this );\r\n\r\n  this.map = map;\r\n\r\n  /****初始化顶层节点的变换矩阵，为了同步mapbox****/\r\n\r\n  // 原点是在（256,256,0）？？？？？？这个目前还不太确定，不过对应于mapbox transform中的一步变换\r\n  this.position.x = this.position.y = constants.WORLD_SIZE / 2;\r\n  // 手动更新变换矩阵\r\n  this.matrixAutoUpdate = false;\r\n  // 开始与map保持同步\r\n  this.syncStart();\r\n\r\n}\r\n\r\nLayerContainer.prototype = Object.assign( Object.create( THREE.Group.prototype ), {\r\n\r\n\tconstructor: LayerContainer,\r\n\r\n  syncStart: function() {\r\n\r\n    var top = this;\r\n    var transform = this.map.transform;\r\n    var TILESIZE = 512;\r\n\r\n    function _synchronize() {\r\n\r\n      // 计算顶层layerContainer的变换矩阵，使其与地图的平移和缩放同步（同步model矩阵），（平移只在xoy面内）\r\n\r\n      // transform.scale = Math.pow(2, zoom)，2的zoom次幂。zoom是地图的缩放级别，0-22，可以是小数\r\n      var zoomPow = transform.scale;\r\n      var scale = new THREE.Matrix4();\r\n      var translateCenter = new THREE.Matrix4();\r\n      var translateMap = new THREE.Matrix4();\r\n      var rotateMap = new THREE.Matrix4();\r\n\r\n      scale.makeScale( zoomPow, zoomPow , zoomPow );\r\n      translateCenter.makeTranslation( TILESIZE / 2, -TILESIZE / 2, 0 ); // ????\r\n      translateMap.makeTranslation( -transform.x, transform.y, 0 );\r\n      rotateMap.makeRotationZ( Math.PI );\r\n      top.matrix = new THREE.Matrix4();\r\n      top.matrix\r\n          .premultiply( rotateMap )\r\n          .premultiply( translateCenter )\r\n          .premultiply( scale )\r\n          .premultiply( translateMap )\r\n\r\n    }\r\n\r\n    // 先同步一次\r\n    _synchronize();\r\n    // 保持同步\r\n    this.map.on( 'move', function() { _synchronize(); } )\r\n\r\n  },\r\n\r\n} );\r\n\r\nmodule.exports = LayerContainer;\r\n"},"hash":"60af447d890a5f395381f477e65cd06b"}