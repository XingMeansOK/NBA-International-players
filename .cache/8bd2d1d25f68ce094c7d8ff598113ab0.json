{"dependencies":[{"name":"./lib/three.js","loc":{"line":1,"column":21}},{"name":"./constant.js","loc":{"line":2,"column":25}}],"generated":{"js":"var THREE = require( './lib/three.js' );\r\nvar constants = require( './constant.js' );\r\n\r\n/*\r\n   Scene\r\n    \\\r\n    LayerContainer --light\r\n     |      \\\r\n    Layer  Layer\r\n\r\n    LayerContainer是所有图层的根节点，为了配合mapbox，LayerContainer还包含了坐标变换\r\n    LayerContainer继承自Three的Group类\r\n    @param map：Mapboxgl Map对象\r\n*/\r\n/**\r\n *     LayerContainer是所有图层的根节点，为了配合mapbox，LayerContainer还包含了坐标变换\r\n *     LayerContainer继承自Three的Group类\r\n * @param       {Mapboxgl Map} map    Mapboxgl Map对象\r\n * @param       {THREE.PespectiveCamera} camera THREE场景的摄像机\r\n * @constructor\r\n */\r\nfunction LayerContainer( map, camera ) {\r\n\r\n  if( !map ) return;\r\n\r\n  THREE.Group.call( this );\r\n\r\n  this.map = map;\r\n\r\n  // 漫反射光\r\n  this.add( new THREE.AmbientLight( 0xcccccc ) );\r\n  // 方向光\r\n  var sunlight = new THREE.DirectionalLight(0xffffff, 0.5);\r\n  sunlight.position.set(0,800,1000); // 没有设置target，默认指向scene原点的一个object3d对象\r\n  sunlight.matrixWorldNeedsUpdate = true;\r\n  this.add(sunlight);\r\n\r\n\r\n  /****初始化顶层节点的变换矩阵，为了同步mapbox****/\r\n\r\n  // 原点是在（256,256,0）？？？？？？这个目前还不太确定，不过对应于mapbox transform中的一步变换\r\n  this.position.x = this.position.y = constants.WORLD_SIZE / 2;\r\n  // 手动更新变换矩阵\r\n  this.matrixAutoUpdate = false;\r\n  // 开始与map保持同步\r\n  this.syncStart();\r\n\r\n  /**\r\n   * 添加raycaster鼠标交互\r\n   */\r\n  this.raycasterStart( camera );\r\n\r\n}\r\n\r\nLayerContainer.prototype = Object.assign( Object.create( THREE.Group.prototype ), {\r\n\r\n\tconstructor: LayerContainer,\r\n\r\n  syncStart: function() {\r\n\r\n    var top = this;\r\n    var transform = this.map.transform;\r\n    var TILESIZE = 512;\r\n\r\n    function _synchronize() {\r\n\r\n      // 计算顶层layerContainer的变换矩阵，使其与地图的平移和缩放同步（同步model矩阵），（平移只在xoy面内）\r\n\r\n      // transform.scale = Math.pow(2, zoom)，2的zoom次幂。zoom是地图的缩放级别，0-22，可以是小数\r\n      var zoomPow = transform.scale;\r\n      var scale = new THREE.Matrix4();\r\n      var translateCenter = new THREE.Matrix4();\r\n      var translateMap = new THREE.Matrix4();\r\n      var rotateMap = new THREE.Matrix4();\r\n\r\n      scale.makeScale( zoomPow, zoomPow , zoomPow );\r\n      translateCenter.makeTranslation( TILESIZE / 2, -TILESIZE / 2, 0 ); // ????\r\n      translateMap.makeTranslation( -transform.x, transform.y, 0 );\r\n      rotateMap.makeRotationZ( Math.PI );\r\n      top.matrix = new THREE.Matrix4();\r\n      top.matrix\r\n          .premultiply( rotateMap )\r\n          .premultiply( translateCenter )\r\n          .premultiply( scale )\r\n          .premultiply( translateMap )\r\n\r\n      top.matrixWorldNeedsUpdate = true; // 如果不设置为true就是不会更新matrixWorld，但是没影响啊，为啥？？？？？？\r\n      /**\r\n       * 为什么这里修改的是matrix而不是像相机一样修改matrixWorld？\r\n       * 实际上是一样的。因为layerContainer的父节点就是scene了，而scene没有任何变换\r\n       */\r\n\r\n    }\r\n\r\n    // 先同步一次\r\n    _synchronize();\r\n    // 保持同步\r\n    this.map.on( 'move', function() { _synchronize(); } )\r\n\r\n  },\r\n\r\n  /**\r\n   * 执行该函数之后，raycaster开始工作\r\n   * @param {THREE.PespectiveCamera} camera Three场景的摄像机\r\n   * @return {[type]} [description]\r\n   *\r\n   * 将来需要处理下兼容性问题\r\n   */\r\n  raycasterStart: function( camera ) {\r\n\r\n    // 初始化射线\r\n    var raycaster = new THREE.Raycaster();\r\n    // 用于保存鼠标位置的向量\r\n    var mouse = new THREE.Vector2();\r\n    // 用于保存three画布的宽高\r\n    var SCREEN_WIDTH, SCREEN_HEIGHT;\r\n    // 持有当前LayerContainer对象的引用\r\n    var top = this;\r\n    // picking ray找到的离摄像机最近的Object3D对象\r\n    var nearest;\r\n\r\n    // 处理鼠标移动\r\n    document.addEventListener( 'mousemove', _r, false );\r\n\r\n    function _r( event ) {\r\n\r\n      if( top.children.length < 3 ) return; // 除了两个灯光之外没有其他子节点了，也就是没有加任何图层\r\n\r\n      event.preventDefault();\r\n\r\n      if( nearest && 'highlight' in nearest ) nearest.highlight = false;\r\n\r\n      // 获取canvas尺寸（可能由于窗口变化而变化）\r\n      SCREEN_WIDTH = top.map.transform.width;\r\n      SCREEN_HEIGHT = top.map.transform.height;\r\n\r\n      // 鼠标的屏幕坐标转化为规格化设备坐标：坐标范围在-1到1之间\r\n      mouse.x = ( event.clientX / SCREEN_WIDTH ) * 2 - 1;\r\n      mouse.y = - ( event.clientY / SCREEN_HEIGHT ) * 2 + 1;\r\n      /*\r\n        屏幕坐标（原点在左上角，x指向右，y指向下）到规格化设备坐标NDC（原点在屏幕中心，xy都是-1到1）的坐标转换\r\n        x，y为屏幕坐标，XY为NDC坐标，WH为屏幕宽高，这里认为画布是充满整个window\r\n        1.屏幕坐标区间长度映射到2：\r\n          2x/w，2y/h，也就是x坐标区间由0-W变为0-2，y由0-H变为0-2\r\n        2.变换坐标原点：\r\n          2x/w - 1, 2y/h -1\r\n        3.改变y轴方向：\r\n          2x/w - 1, -2y/h + 1\r\n      */\r\n\r\n      raycaster.setFromCamera( mouse, camera );\r\n      // 获取LayerContainer中与picking ray相交的子节点的集合； 第二个true表示同时迭代子节点\r\n      var intersects = raycaster.intersectObjects( top.children, true ); // 返回结果[ { distance, point, face, faceIndex, indices, object }, ... ]\r\n\r\n      if (!intersects[0]) return\r\n\r\n      nearest = intersects[0].object;\r\n      // 高光显示选中的物体\r\n      if( 'highlight' in nearest ) nearest.highlight = true;\r\n      // console.log( nearest );\r\n\r\n\r\n    }\r\n\r\n  }\r\n\r\n} );\r\n\r\nmodule.exports = LayerContainer;\r\n"},"hash":"2a140a89e931fa50f3da5b8f96ca1ce7"}