{"dependencies":[{"name":"../lib/three.js","loc":{"line":1,"column":21}},{"name":"../layer.js","loc":{"line":2,"column":21}},{"name":"../lib/tweenjs.js","loc":{"line":3,"column":24}}],"generated":{"js":"var THREE = require( '../lib/three.js' );\r\nvar Layer = require( '../layer.js' );\r\nvar createjs = require( '../lib/tweenjs.js' );\r\n\r\n/**\r\n * 柱子图层，继承自layer\r\n * @param       {Object} options 添加图层的数据参数 属性格式参考Mapboxgl 的style layers  https://www.mapbox.com/mapbox-gl-js/style-spec/#layers\r\n * @constructor\r\n * @example   options { id: 'XX', type: 'pillarlayer'\r\n                         source:{\r\n                           type:\"geojson\",\r\n                           data:\"./XX.geojson\" 文件的位置\r\n                         }\r\n                       }\r\n *\r\n * 如果可视化都集中在一个很小的区域，柱子的粗细就要随之变小\r\n */\r\nfunction PillarLayer( options ) {\r\n\r\n  Layer.call( this );\r\n\r\n  // 请求参数\r\n  var requestParameters = {\r\n    url: options.source.data\r\n  };\r\n\r\n  var scope = this;\r\n\r\n  // 读取数据\r\n  this.getJSON( requestParameters, function( err, data ) {\r\n\r\n    if( err ) {\r\n      console.log( err.status + ':' + err.message );\r\n    }\r\n    // 如果数据读取成功，添加柱子\r\n    scope.addPillars( data );\r\n\r\n  } )\r\n\r\n}\r\n\r\nPillarLayer.prototype = Object.assign( Object.create( Layer.prototype ), {\r\n\r\n  constructor: PillarLayer,\r\n\r\n  /**\r\n   * 根据读取到的数据添加柱子\r\n   * @param  {Object} data 数据源\r\n   * @return {[type]}      [description]\r\n   */\r\n  addPillars: function( data ) {\r\n\r\n    var pillar, position;\r\n    var features = data.features;\r\n\r\n    for( var i = 0; i < features.length; i++ ) {\r\n\r\n      pillar = new Pillar( features[i].properties.size * 100000 );\r\n      position = features[i].geometry.coordinates; // 可以有第三个元素，表示离地面的高度\r\n      this.addAtCoordinate(pillar, position, {scaleToLatitude: true});\r\n\r\n    }\r\n\r\n  }\r\n\r\n} );\r\n\r\n/*\r\n  柱子\r\n*/\r\nfunction Pillar( height ) {\r\n\r\n  var SIDE = 100000;\r\n\r\n  var geometry = new THREE.BoxGeometry( SIDE, SIDE, 1 );\r\n\r\n  geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, 0.5 ) ); // x,y,z方向上的平移量\r\n  // 初始的几何体的中心是和世界坐标的原点重合的，这里沿z轴正方向平移，立方体的nz面和世界坐标的原点重合\r\n  // 相当于修改几何体的中心点位置，原来的中心是在几何体的中心，现在是在nz面的中心\r\n\r\n  // 柱子的材质\r\n  // var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );\r\n  var material = new THREE.MeshPhongMaterial( {\r\n    color: 0x7777ff,\r\n    specular:0x7777ff,\r\n    shininess:30\r\n   } )\r\n\r\n  THREE.Mesh.call( this, geometry, material );\r\n\r\n  // this.scale.z就代表了柱子所代表的数据大小\r\n  this.scale.z = 1; // 因为tween是从当前值变化到目标值，所以要先设置下当前值\r\n  this.updateMatrix();\r\n\r\n  // 柱子动态生长的特效\r\n  createjs.Tween.get( this )\r\n    .wait( 500 )\r\n    .to( { height: height || 1 }, 1000, createjs.Ease.quartInOut );\r\n\r\n}\r\n\r\nPillar.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nObject.defineProperties( Pillar.prototype, {\r\n\r\n  // tween.js将修改height属性，来得到柱子长高的动画效果\r\n  height: {\r\n\r\n    set: function( newValue ) {\r\n\r\n      // 除了这种方式，morphTargetInfluences可以做到更广义的变形，将来研究下\r\n      this.scale.z = Math.max( newValue, 1 );\r\n      // 每次修改之后都要更新矩阵\r\n      this.updateMatrix();\r\n\r\n    },\r\n\r\n    get: function() {\r\n\r\n      return this.scale.z;\r\n\r\n    }\r\n  }\r\n} )\r\n\r\n\r\nmodule.exports = PillarLayer;\r\n"},"hash":"91cd2b3b5516c70ffc2b713b2aff45a2"}