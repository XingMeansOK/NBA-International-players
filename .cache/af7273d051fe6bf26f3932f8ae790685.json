{"dependencies":[{"name":"../lib/three.js","loc":{"line":1,"column":21}},{"name":"../layer.js","loc":{"line":2,"column":21}},{"name":"../lib/tweenjs.js","loc":{"line":3,"column":24}}],"generated":{"js":"var THREE = require( '../lib/three.js' );\r\nvar Layer = require( '../layer.js' );\r\nvar createjs = require( '../lib/tweenjs.js' );\r\n\r\n/*\r\n  柱子图层，继承自layer\r\n*/\r\nfunction PillarLayer( options ) {\r\n\r\n  Layer.call( this );\r\n\r\n  var pillar = new Pillar( 3000000 );\r\n  var planePosition = [ -102.41356, 37.77577 ]; // 可以有第三个元素，表示离地面的高度\r\n  this.addAtCoordinate(pillar, planePosition, {scaleToLatitude: true});\r\n\r\n  pillar = new Pillar( 2000000 );\r\n  planePosition = [ -112.41356, 37.77577 ]; // 可以有第三个元素，表示离地面的高度\r\n  this.addAtCoordinate(pillar, planePosition, {scaleToLatitude: true});\r\n\r\n  pillar = new Pillar( 1000000 );\r\n  planePosition = [ -132.41356, 37.77577 ]; // 可以有第三个元素，表示离地面的高度\r\n  this.addAtCoordinate(pillar, planePosition, {scaleToLatitude: true});\r\n\r\n}\r\n\r\nPillarLayer.prototype = Object.assign( Object.create( Layer.prototype ), {\r\n\r\n  constructor: PillarLayer,\r\n\r\n\r\n\r\n} );\r\n\r\n/*\r\n  柱子\r\n*/\r\nfunction Pillar( height ) {\r\n\r\n  var SIDE = 100000;\r\n\r\n  var geometry = new THREE.BoxGeometry( SIDE, SIDE, 1 );\r\n\r\n  geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, 0.5 ) ); // x,y,z方向上的平移量\r\n  // 初始的几何体的中心是和世界坐标的原点重合的，这里沿z轴正方向平移，立方体的nz面和世界坐标的原点重合\r\n  // 相当于修改几何体的中心点位置，原来的中心是在几何体的中心，现在是在nz面的中心\r\n\r\n  // 柱子的材质\r\n  var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );\r\n  THREE.Mesh.call( this, geometry, material );\r\n\r\n  // this.scale.z就代表了柱子所代表的数据大小\r\n  this.scale.z = 1; // 因为tween是从当前值变化到目标值，所以要先设置下当前值\r\n  this.updateMatrix();\r\n\r\n  // 柱子动态生长的特效\r\n  createjs.Tween.get( this )\r\n    .wait( 500 )\r\n    .to( { height: height || 1 }, 1000, createjs.Ease.quartInOut );\r\n\r\n}\r\n\r\nPillar.prototype = Object.create( THREE.Mesh.prototype );\r\nObject.defineProperties( Pillar.prototype, {\r\n\r\n  height: {\r\n    set: function( newValue ) {\r\n      // 除了这种方式，morphTargetInfluences可以做到更广义的变形，将来研究下\r\n      this.scale.z = Math.max( newValue, 1 );\r\n      // 每次修改之后都要更新矩阵\r\n      this.updateMatrix();\r\n    },\r\n    get: function() {\r\n      return this.scale.z;\r\n    }\r\n  }\r\n} )\r\n\r\n\r\nmodule.exports = PillarLayer;\r\n"},"hash":"7cc73605b5c93798df89ccab677c47f0"}